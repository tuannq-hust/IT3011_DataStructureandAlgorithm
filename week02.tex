% Supported aspectratio 43|169, default is 43
\documentclass[aspectratio=169]{beamer}
\usetheme[theme=blue,logo=logowithtextvi]{HUST} % <-- this matches beamerthemeHUST.sty

% \usepackage[utf8]{vietnam}
\usepackage[T5]{fontenc}
\usepackage{lmodern}
% \setmainfont{assets/fonts/LATO-BLACK.TTF}
\usepackage{enumitem}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc}
% Độ dày mặt ellipse
\newcommand{\CylEy}{0.28}

% \cyl{R}{y_bottom}{H}{color}
\newcommand{\cyl}[4]{%
  \pgfmathsetmacro{\ytop}{#2 + #3}%
  \path[fill=#4, draw=black]
    (-#1,\ytop) arc(180:360:#1 and \CylEy) -- (#1,#2)
    arc(0:-180:#1 and \CylEy) -- cycle;
  \path[fill=#4, draw=black] (0,\ytop) ellipse (#1 and \CylEy);
  \draw[black] (#1,#2) arc(0:-180:#1 and \CylEy);
}
\usepackage{forest}
\forestset{
  combtree/.style={
    for tree={
      draw,
      ellipse,
      fill=cyan!20,
      align=center,
      font=\small\bfseries\color{red},
      inner sep=2pt,
      minimum height=7mm,
      edge={draw=black, line width=.4pt},
      l sep=9mm,  % khoảng cách dọc
      s sep=8mm   % khoảng cách ngang
    }
  }
}


\usepackage{minted}

\usetikzlibrary{decorations.pathreplacing,arrows.meta}

\tcbuselibrary{listingsutf8}




\newcommand{\placecontent}[4]{%
  \tikz[remember picture,overlay]
    \node[anchor=north west]
      at ([xshift=#1,yshift=-#2]current page.north west)
      {\parbox{#3}{#4}};
}


\title{CẤU TRÚC DỮ LIỆU VÀ THUẬT TOÁN}
\author{SoICT - HUST}
\date{}
\setbeamertemplate{footline}{%
  \hfill%
  \insertframenumber\hspace{0.5cm}\vspace{0.3cm}
  }
\begin{document}

\HUSTInsertBrandSlide
\HUSTInsertThemeSlide

% Title slide - place it here for your customization
{\HUSTUseBackground{onelove.pdf}
\begin{frame}
  \ifdefstring{\insertaspectratio}{169}{
    \HUSTCornerImage{assets/logo/04.pdf}

    %----------You can edit here----------
    \placecontent{0.5cm}{0.33\paperheight}{0.85\paperwidth}{
        \color{\HUSTFrameTitleTextColor}\bfseries\fontsize{22pt}{30pt}\selectfont
        \inserttitle
    }
    % \placecontent{0.5cm}{0.48\paperheight}{10cm}{    % one-line title
    \placecontent{0.5cm}{0.60\paperheight}{0.5\paperwidth}{    % two-line title
        \color{\HUSTFrameTitleTextColor}\fontsize{12pt}{14pt}\selectfont
        TUẦN 2: ĐỆ QUY, ĐỆ QUY CÓ NHỚ\\
        \insertauthor
    }
  }{}
  \ifdefstring{\insertaspectratio}{43}{
    \HUSTCornerImage[0.1][0.35cm][-0.03]{assets/logo/04.pdf}

    %----------You can edit here----------
    \placecontent{0.5cm}{0.33\paperheight}{0.80\paperwidth}{
        \color{\HUSTFrameTitleTextColor}\bfseries\fontsize{18pt}{22pt}\selectfont
        \inserttitle
    }
    % \placecontent{0.5cm}{0.48\paperheight}{10cm}{    % one-line title
    \placecontent{0.5cm}{0.60\paperheight}{0.5\paperwidth}{    % two-line title
        \color{\HUSTFrameTitleTextColor}\fontsize{12pt}{14pt}\selectfont
        TUẦN 1 : CÁC KHÁI NIỆM CƠ BẢN\\
        \insertauthor
    }
  }{}
\end{frame}
}

% Display the tableofcontents before a section
\AtBeginSection[]
{
    \begin{frame}<beamer>
        \frametitle{MỤC LỤC}
        \tableofcontents[currentsection]
    \end{frame}
}

\section{Khái niệm cơ bản}
\begin{frame}{Khái niệm cơ bản}
  \begin{itemize}
    \item Đối tượng đệ quy: được xác định thông qua chính nó nhưng với quy mô nhỏ hơn
    \item Hàm đệ quy
          \begin{itemize}
            \item Bước cơ sở: xác định giá trị của hàm với một số giá trị tham số ban đầu
            \item Bước đệ quy: Xác định mối quan hệ giữa hàm phụ thuộc vào chính hàm đó nhưng với tham số nhỏ hơn
          \end{itemize}
    \item Ví dụ:
          \begin{columns}[T,onlytextwidth]
            % Cột trái: code (nửa trang)
            \begin{column}{0.45\textwidth}
              \vspace{0.5cm}
              Bài toán tìm số Fibonacci
              \begin{itemize}
                \item Cở sở: $F(n)=1$ với $n=1$
                \item Đệ quy: $F(n)=F(n-1)+n$ với $n>1$
              \end{itemize}
            \end{column}
            \begin{column}{0.45\textwidth}
              \vspace{0.5cm}
              Bài toán tính tổ hợp chập $k$ của $n$
              \begin{itemize}
                \item Cơ sở: $C_n^{k}=1$ với $k=0$ hoặc $k=n$
                \item Đệ quy: $C_n^k=C_{n-1}^{k-1}+C_{n-1}^{k}$, với các trường hợp còn lại
              \end{itemize}
            \end{column}
          \end{columns}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Khái niệm cơ bản}
  \begin{itemize}
    \item Tập hợp được xác định đệ quy
          \begin{itemize}
            \item Bước cơ sở: Xác định phần tử đầu tiên của tập hợp
            \item Bước đệ quy: Xác định luật cho biết các phần tử lớn hơn thuộc tập hợp từ các phần tử ban đầu
          \end{itemize}
    \item Ví dụ:
          \begin{itemize}
            \item Cơ sở: $3$ thuộc tập $S$
            \item Đệ quy: Nếu $x$ và $y$ thuộc tập $S$ thì $x+y$ và $x-y$ cũng thuộc tập $S$
          \end{itemize}
  \end{itemize}
\end{frame}

\section{Sơ đồ chung đệ quy}
\begin{frame}[fragile]{Khái niệm cơ bản}
  \begin{itemize}
    \item Thuật toán đệ quy là thuật toán tự gọi đến chính mình với đầu vào kích thước nhỏ hơn
    \item Thuật toán đệ quy thường được dùng khi cần xử lý với các đối tượng được định nghĩa đệ quy
    \item Ví dụ: hàm tính dãy số Fibonacci
          \begin{itemize}
            \item $f(0)=0,\,\,f(1)=1,$
            \item $f(n)=f(n-1)+f(n-2),\,\,n\ge 2$
          \end{itemize}
    \item  Các ngôn ngữ lập trình bậc cao thường cho phép xây dựng các hàm đệ quy, nghĩa là trong thân của hàm có chứa những lệnh gọi đến chính nó. Vì thế, khi cài đặt các thuật toán đệ quy, người ta thường xây dựng các hàm đệ quy
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Khái niệm cơ bản}
  \begin{minted}[style=vs]{c}
DeQuy(input) {
    if (kích thước của input là nhỏ nhất) then
          Thực hiện Bước cơ sở; /* giải bài toán kích thước đầu vào nhỏ nhất */
    else {
          DeQuy(input với kích thước nhỏ hơn); /* bước đệ quy */
          /* Chú ý: có thể có thêm những lệnh gọi đệ quy */
          Tổ hợp lời giải của các bài toán con để thu được lời_giải;
          return lời_giải;
  }
}
\end{minted}
  \begin{itemize}
    \item Ví dụ: Tính $n!$ theo công thức đệ quy:
          \begin{itemize}
            \item Cơ sở: $f(0)=1$
            \item Đệ quy: $f(n)=n\times f(n-1)$ với $n\ge 1$
          \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Sơ đồ chung đệ quy}
  \begin{columns}[T,onlytextwidth]
    % Cột trái: code (nửa trang)
    \begin{column}{0.5\textwidth}
      \vspace{-0.6cm}
      \begin{minted}[style=vs]{text}
            factorial(3):
                3 == 0 ? No
                return 3 * factorial(2)
      \end{minted}
      \vspace{0.35cm}
      \begin{minted}[style=vs]{text}
            factorial(2):
                2 == 0 ? No
                return 2 * factorial(1)
      \end{minted}
      \vspace{0.35cm}
      \begin{minted}[style=vs]{text}
            factorial(1):
                1 == 0 ? No
                return 1 * factorial(0)
      \end{minted}
      \vspace{0.35cm}
      \begin{minted}[style=vs]{text}
            factorial(0):
                0 == 0 ? Yes
                return 1
      \end{minted}
    \end{column}
    \begin{column}{0.4\textwidth}
      \begin{minted}[style=vs]{c}
             int factorial(int n) {
               if (n == 0) return 1; // Bước cơ sở
               else return n * factorial(n - 1); // Bước đệ quy
             }
             \end{minted}
      \vspace{0.3cm}
      Thực thi hàm factorial(3) sẽ dừng cho đến khi hàm factorial(2) trả về kết quả. Khi hàm factorial(2) trả về kết quả, hàm factorial(3) sẽ tiếp tục thực thi.
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Sơ đồ chung đệ quy}
  \begin{itemize}
    \item Ví dụ: Tính dãy số Fibonacci theo công thức đệ quy:
          \begin{itemize}
            \item Cơ sở: $f(0)=0,\,\,f(1)=1,$
            \item Đệ quy: $f(n)=f(n-1)+f(n-2),\,\,n\ge 2$
          \end{itemize}
    \item Cài đặt hàm đệ quy tính số Fibonacci:
          \begin{minted}[style=vs]{c}
int F(int n) {
  if (n == 0) return 0; // Bước cơ sở
  else if (n == 1) return 1; // Bước cơ sở
  else return F(n - 1) + F(n - 2); // Bước đệ quy
}
\end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Sơ đồ chung đệ quy}
  \begin{itemize}
    \item Ví dụ: Bài toán Tháp Hà Nội
  \end{itemize}
  Bài toán Tháp Hà Nội được trình bày như sau: Có $3$ cọc $a, b, c$. Trên cọc a có một chồng gồm $n$ cái đĩa,
  đường kính giảm dần từ dưới lên trên. Cần phải chuyển chồng đĩa từ cọc $a$ sang cọc $c$ tuân thủ quy tắc:
  \begin{center}
    \textit{1. Mỗi lần chỉ chuyển được một đĩa}

    \textit{2. Chỉ được xếp đĩa có đường kính nhỏ hơn lên trên đĩa có đường kính lớn hơn. Trong quá trình chuyển được phép dùng cọc $b$ làm cọc trung gian}
  \end{center}
  Bài toán đặt ra là: Hãy liệt kê các bước di chuyển đĩa cần thực hiện để hoàn thành nhiệm vụ đặt ra
  của bài toán.
\end{frame}

\begin{frame}[fragile]{Sơ đồ chung đệ quy }
  Chuyển $n$ đĩa từ cọc $a$ sang cọc $c$ sử dụng cọc $b$ làm cọc trung gian được mô tả bằng hàm $\mathbf{HanoiTower}(n, a, c, b)$. Việc di chuyển đĩa gồm 3 giai đoạn:
  \begin{itemize}
    \item Giai đoạn 1: Chuyển $n-1$ đĩa từ cọc $a$ sang cọc $b$ sử dụng cọc $c$ làm cọc trung gian
    \item Giai đoạn 2: Chuyển đĩa thứ $n$ từ cọc $a$ sang cọc $c$
    \item Giai đoạn 3: Chuyển $n-1$ đĩa từ cọc $b$ sang cọc $c$ sử dụng cọc $a$ làm cọc trung gian
  \end{itemize}
  \begin{center}
    \begin{tikzpicture}[
        line join=round, line cap=round, line width=0.6pt,
        scale=0.5, transform shape, % <-- chỉnh nhỏ/to tại đây
        baseline=(base)
      ]
      \coordinate (base) at (0,0);

      % ===== Cọc a (giữ nguyên các đĩa vàng) =====
      \begin{scope}[shift={(0,0)}]
        \draw[fill=white] (-3.6,0) rectangle (3.6,1.2);
        \node[font=\LARGE] at (0,0.55) {Cọc a};

        \cyl{3.10}{1.20}{0.80}{yellow!70}
        \cyl{2.55}{2.00}{0.75}{yellow!70}
        \cyl{2.00}{2.75}{0.70}{yellow!70}
        \cyl{1.45}{3.45}{0.65}{yellow!70}
        \cyl{0.95}{4.10}{0.60}{yellow!70}
      \end{scope}

      % ===== Cọc c (chỉ hộp chữ) =====
      \begin{scope}[shift={(9,0)}] % <-- khoảng cách cọc c
        \draw[fill=white] (-3.6,0) rectangle (3.6,1.2);
        \node[font=\LARGE] at (0,0.55) {Cọc c};
      \end{scope}

      % ===== Cọc b (chỉ hộp chữ) =====
      \begin{scope}[shift={(18,0)}] % <-- khoảng cách cọc b
        \draw[fill=white] (-3.6,0) rectangle (3.6,1.2);
        \node[font=\LARGE] at (0,0.55) {Cọc b};
      \end{scope}

    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Sơ đồ chung đệ quy }
  Phân tích các bước trong hàm $\mathbf{HanoiTower}(n, a, c, b)$
  \begin{itemize}
    \item Bước cơ sở: Nếu $n=1$, chuyển đĩa từ cọc $a$ sang cọc $c$
    \item Bước đệ quy:
          \begin{itemize}
            \item Chuyển $n-1$ đĩa từ cọc $a$ sang cọc $b$ sử dụng cọc $c$ làm cọc trung gian bằng cách gọi đệ quy hàm $\mathbf{HanoiTower}(n-1, a, b, c)$
            \item Chuyển một đĩa (đĩa với đường kính lớn nhất) từ cọc $a$ sang cọc $c$ gọi hàm $\mathbf{HanoiTower}(1, a, c, b)$
            \item Chuyển $n-1$ đĩa từ cọc $b$ sang cọc $c$ sử dụng cọc $a$ làm cọc trung gian bằng cách gọi đệ quy hàm $\mathbf{HanoiTower}(n-1, b, c, a)$
          \end{itemize}
  \end{itemize}
  \begin{center}
    \begin{tikzpicture}[
        line join=round, line cap=round, line width=0.6pt,
        scale=0.5, transform shape, % <-- chỉnh nhỏ/to tại đây
        baseline=(base)
      ]
      \coordinate (base) at (0,0);

      % ===== Cọc a (giữ nguyên các đĩa vàng) =====
      \begin{scope}[shift={(0,0)}]
        \draw[fill=white] (-3.6,0) rectangle (3.6,1.2);
        \node[font=\LARGE] at (0,0.55) {Cọc a};

        \cyl{3.10}{1.20}{0.80}{yellow!70}
        \cyl{2.55}{2.00}{0.75}{yellow!70}
        \cyl{2.00}{2.75}{0.70}{yellow!70}
        \cyl{1.45}{3.45}{0.65}{yellow!70}
        \cyl{0.95}{4.10}{0.60}{yellow!70}
      \end{scope}

      % ===== Cọc c (chỉ hộp chữ) =====
      \begin{scope}[shift={(9,0)}] % <-- khoảng cách cọc c
        \draw[fill=white] (-3.6,0) rectangle (3.6,1.2);
        \node[font=\LARGE] at (0,0.55) {Cọc c};
      \end{scope}

      % ===== Cọc b (chỉ hộp chữ) =====
      \begin{scope}[shift={(18,0)}] % <-- khoảng cách cọc b
        \draw[fill=white] (-3.6,0) rectangle (3.6,1.2);
        \node[font=\LARGE] at (0,0.55) {Cọc b};
      \end{scope}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Sơ đồ chung đệ quy }
  Thuật toán có thể mô tả trong thủ tục đệ quy sau:
  \begin{minted}[style=vs]{c}
 HanoiTower(n, a, c, b) {//chuyển n đĩa từ cọc a sang cọc c sử dụng cọc b làm trung gian:
 if (n==1) then <chuyển đĩa từ cọc a sang cọc c>
 else {
 HanoiTower(n-1,a,b,c);
 HanoiTower(1,a,c,b);
 HanoiTower(n-1,b,c,a);
 }
}
\end{minted}
  \vspace{1cm}
  Sau đây là cách cài đặt thuật toán đầy đủ
\end{frame}

\begin{frame}[fragile]{Sơ đồ chung đệ quy }
  \begin{minted}[style=vs]{c}
#include <stdio.h> 
int i=0;   
void HanoiTower(int n, char xuatphat, char dich, char trunggian) {
    if (n == 1) {
        printf("Chuyen dia tu coc %c sang coc %c\n", xuatphat, dich); i++;
        return;
    }
    else{
        HanoiTower(n - 1, xuatphat, trunggian, dich); 
        HanoiTower(1, xuatphat, dich, trunggian);
        HanoiTower(n - 1, trunggian, dich, xuatphat); 
    }
}
int main() {
    int n ; 
    printf("Nhap so dia: "); scanf("%d", &n);
    HanoiTower(n, 'A', 'C', 'B'); 
    printf("Tong so buoc di chuyen: %d\n", i;)
    return 0;
}
\end{minted}

\end{frame}

\section{Phân tích thuật toán đệ quy}
\begin{frame}[fragile]{Phân tích thuật toán đệ quy}
  \begin{itemize}
    \item Các bước tiến hành phân tích thuật toán đệ quy
          \begin{itemize}
            \item Gọi $T(n)$ là thời gian tính của thuật toán
            \item Xây dựng công thức đệ quy cho $T(n)$
            \item Giải công thức đệ quy thu được để đưa ra đánh giá cho $T(n)$
          \end{itemize}
    \item Nói chung ta cần một đánh giá sát cho tốc độ tăng của $T(n)$ nên việc giải công thức đệ quy đối với $T(n)$ là đưa ra đánh giá tốc độ tăng của $T(n)$ trong kí hiệu tiệm cận
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Phân tích thuật toán đệ quy}
  Ví dụ: Tính $n!$ theo công thức đệ quy
  \begin{minted}[style=vs]{c}
int F(int n) {
  if (n==0) return 1;
  else 
  return n*F(n-1);
}
\end{minted}
  Gọi $T(n)$ là số phép nhân phải thực hiện trong lệnh gọi $F(n)$.
  \begin{align*}
    T(0)=0; \\
    T(n)=T(n-1)+1; n\ge 1
  \end{align*}

  Từ công thức đệ quy $T(n)=T(n-k)+k$ suy ra $T(n)=T(0)+n$

  Vậy $T(n)=O(n)$.
\end{frame}

\section{Đệ quy có nhớ}
\begin{frame}[fragile]{Đệ quy có nhớ}
  \begin{itemize}
    \item Bài toán con trùng lặp. Trong thuật toán đệ quy, mỗi khi cần đến lời giải của một bài toán con ta lại phải trị nó một cách đệ quy. Do đó, có những bài toán con bị giải đi giải lại nhiều lần. Điều đó dẫn đến tính kém hiệu quả của thuật toán. Hiện tượng này gọi là hiện tượng bài toán con trùng lặp.
  \end{itemize}
  Ví dụ: Tính dãy số Fibonacci
  \begin{minted}[]{c}
    int F(int n){
      if (n<2) return n;
      else return F(n-1) + F(n-2);
    }
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Đệ quy có nhớ}
  Ví dụ: Tính dãy số Fibonacci
  \begin{minted}[]{c}
    int F(int n){
      if (n<2) return n;
      else return F(n-1) + F(n-2);
    }
  \end{minted}
  \begin{center}
    \resizebox{0.6\linewidth}{!}{%
      \begin{forest}
        for tree={
        circle, draw, fill=white,
        inner sep=1.0pt,
        minimum size=3.6mm,
        font=\scriptsize,
        l sep=6mm,
        s sep=3mm,
        edge={draw, line width=0.35pt},
        % --- Nếu muốn có mũi tên đỏ như hình (xấp xỉ): mở comment dòng dưới ---
        % edge+={draw=red, -{Stealth[length=2mm]}, very thin, shorten >=1.2pt, shorten <=1.2pt},
        }
        [$F_7$
        [$F_6$
            [$F_5$
                [$F_4$
                    [$F_3$
                        [$F_2$
                            [$F_1$]
                              [$F_0$]
                          ]
                          [$F_1$]
                      ]
                      [$F_2$
                        [$F_1$]
                          [$F_0$]
                      ]
                  ]
                  [$F_3$
                    [$F_2$
                        [$F_1$]
                          [$F_0$]
                      ]
                      [$F_1$]
                  ]
              ]
              [$F_4$
                [$F_3$
                    [$F_2$
                        [$F_1$]
                          [$F_0$]
                      ]
                      [$F_1$]
                  ]
                  [$F_2$
                    [$F_1$]
                      [$F_0$]
                  ]
              ]
          ]
          [$F_5$
            [$F_4$
                [$F_3$
                    [$F_2$
                        [$F_1$]
                          [$F_0$]
                      ]
                      [$F_1$]
                  ]
                  [$F_2$
                    [$F_1$]
                      [$F_0$]
                  ]
              ]
              [$F_3$
                [$F_2$
                    [$F_1$]
                      [$F_0$]
                  ]
                  [$F_1$]
              ]
          ]
        ]
      \end{forest}%
    }
  \end{center}
\end{frame}

\begin{frame}[fragile]{Đệ quy có nhớ}
  Ví dụ: Tính hệ số định thức
  \begin{minted}[]{c}
    int C(int k, int n){
      if (k == 0 || k===n) return 1;
      else return C(k-1;n-1)+C(k,n-1);
    }
  \end{minted}
  \centering

  \resizebox{0.6\linewidth}{!}{%
    \begin{forest} combtree
      [{$C(3,5)$}
        [{$C(2,4)$}
            [{$C(1,3)$}
                [{$C(0,2)$}] % <-- xóa C(0,1)
                [{$C(1,2)$}
                    [{$C(0,1)$}]
                    [{$C(1,1)$}]
                ]
            ]
            [{$C(2,3)$}
                [{$C(1,2)$}
                    [{$C(0,1)$}]
                    [{$C(1,1)$}]
                ]
                [{$C(2,2)$}]
            ]
        ]
        [{$C(3,4)$}
            [{$C(2,3)$}
                [{$C(1,2)$}
                    [{$C(0,1)$}]
                    [{$C(1,1)$}]
                ]
                [{$C(2,2)$}]
            ]
            [{$C(3,3)$}] % <-- xóa C(2,2)
        ]
      ]
    \end{forest}%
  }

\end{frame}

\begin{frame}[fragile]{Đệ quy có nhớ}
  \begin{itemize}
    \item Trong hai ví dụ trên, ta đã thấy các thuật toán đệ quy để tính số Fibonacci và tính hệ số nhị thức là kém hiệu quả.
    \item Để tăng hiệu quả của các thuật toán đệ quy, ta có thể sử dụng kỹ thuật đệ quy có nhớ.
  \end{itemize}
  Sử dụng kỹ thuật đệ quy có nhớ, trong nhiều trường hợp, ta giữ nguyên được cấu trúc đệ quy của thuật toán và đồng thời lại đảm bảo được hiệu quả của nó. Nhược điểm lớn nhất của cách làm này là đòi hỏi về bộ nhớ
  \begin{itemize}
    \item Ý tưởng đệ quy có nhớ: Dùng biến ghi nhớ lại thông tin về lời giải của các bài toán con ngay sau lần đầu tiên nó được giải. Điều đó cho phép rút ngắn thời gian tính của thuật toán, bởi vì, mỗi khi cần đến có thể tra cứu mà không phải giải lại những bài toán con đã được giải trước đó.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Đệ quy có nhớ}
  \begin{itemize}
    \item Cách cài đặt thuật toán đệ quy có nhớ
  \end{itemize}
  Ví dụ: Tính dãy số Fibonacci

  \begin{minted}[]{c}
    void init() {
      M[0] = 0; M[1] = 1;
      for (int i = 2; i <= n; i++) M[i] = 0;
}
    int F(int n){
      if (n!= 0 && M[n] == 0)M[n] = F(n-1) + F(n-2);
      return M[n];
}
  \end{minted}
  Trước khi gọi hàm $F(n)$ cần gọi hàm $\mathbf{init()}$ để khởi tạo các phần tử trong mảng $\mathbf{M[ \hspace{0.2cm}]}$ như sau:

  \begin{align*}
    M[0]=0, M[1]=1, \\
    M[i]=0, \text{với} i\ge2.
  \end{align*}
\end{frame}

\begin{frame}[fragile]{Đệ quy có nhớ}

  Ví dụ: Tính hệ số nhị thức
  \begin{minted}[]{c}
    void init() {
      for (int i = 0; i <= k; i++)
        for(int j = 0; j <= n; j++) M[i][j] = 0;
}
    int C(int k, int n) {
      if (k == 0 || k == n) M[k][n] = 1;
      else {
      if(M[k][n] == 0) M[k][n] = C(k-1,n-1) + C(k,n-1);
 }
      return M[k][n];
}
  \end{minted}
  Trước khi gọi hàm $C(k,n)$ cần gọi hàm $\mathbf{init()}$ để khởi tạo các phần tử trong mảng $\mathbf{M[ \hspace{0.2cm}][\hspace{0.2cm} ]}=0$
\end{frame}

{\HUSTUseBackground{theme_hust_oneside.pdf}
\begin{frame}
  \ifdefstring{\insertaspectratio}{169}{
    \placecontent{0.355\paperwidth}{0.320\paperheight}{0.640\paperwidth}{
        \color{HUSTRed}\bfseries\fontsize{28pt}{36pt}\selectfont\centering
        CẢM ƠN \\ĐÃ LẮNG NGHE!
    }
  }{}
  \ifdefstring{\insertaspectratio}{43}{
    \placecontent{0.355\paperwidth}{0.350\paperheight}{0.640\paperwidth}{
        \color{HUSTRed}\bfseries\fontsize{28pt}{36pt}\selectfont\centering
        CẢM ƠN \\ĐÃ LẮNG NGHE!
    }
  }{}
\end{frame}
}

\end{document}
